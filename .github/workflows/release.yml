name: Test and Release to PyPI

on:
  push:
    branches: [ main ]  # Only release from main branch

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
        pip install -e .
        pip install pytest pytest-cov
        pip install build twine
    
    - name: Run tests
      run: |
        pytest tests/ -v --cov=src --cov-report=term-missing
    
    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
    
    - name: Sync version with git tags
      run: |
        # Get the latest git tag
        latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.2.47")
        latest_version=${latest_tag#v}
        
        # Read current version from __version__.py
        current_version=$(python -c "import sys; sys.path.insert(0, 'src'); from refchecker.__version__ import __version__; print(__version__)")
        
        # If git tag version is newer than __version__.py, update __version__.py
        if [ "$latest_version" != "$current_version" ]; then
          echo "Syncing __version__.py ($current_version) with git tag ($latest_version)"
          sed -i "s/__version__ = \".*\"/__version__ = \"$latest_version\"/" src/refchecker/__version__.py
          
          # Commit the sync if needed
          if git diff --quiet src/refchecker/__version__.py; then
            echo "No version sync needed"
          else
            git add src/refchecker/__version__.py
            git commit -m "Sync version with git tag v$latest_version"
            git push
          fi
        else
          echo "Version already in sync: $current_version"
        fi
    
    - name: Increment version
      id: increment_version
      run: |
        # Get the latest git tag
        latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.2.47")
        echo "Latest git tag: $latest_tag"
        
        # Extract version number from tag (remove 'v' prefix if present)
        latest_version=${latest_tag#v}
        echo "Latest version from git: $latest_version"
        
        # Read current version from __version__.py
        current_version=$(python -c "import sys; sys.path.insert(0, 'src'); from refchecker.__version__ import __version__; print(__version__)")
        echo "Current version in __version__.py: $current_version"
        
        # Use the higher version as the base
        if [ "$latest_version" != "$current_version" ]; then
          echo "Version mismatch detected. Using git tag version as base."
          base_version=$latest_version
        else
          base_version=$current_version
        fi
        
        # Parse version parts (assuming semantic versioning: major.minor.patch)
        IFS='.' read -r major minor patch <<< "$base_version"
        
        # Increment patch version
        new_patch=$((patch + 1))
        new_version="${major}.${minor}.${new_patch}"
        
        echo "New version: $new_version"
        
        # Update __version__.py
        sed -i "s/__version__ = \".*\"/__version__ = \"$new_version\"/" src/refchecker/__version__.py
        
        # Set output for later steps
        echo "new_version=$new_version" >> $GITHUB_OUTPUT
        echo "current_version=$base_version" >> $GITHUB_OUTPUT
    
    - name: Commit version bump
      run: |
        git add src/refchecker/__version__.py
        git commit -m "Bump version to ${{ steps.increment_version.outputs.new_version }}"
        git push
    
    - name: Run build script
      run: |
        chmod +x build.sh
        ./build.sh
    
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        twine upload dist/* --verbose
    
    - name: Create GitHub Release
      run: |
        gh release create "v${{ steps.increment_version.outputs.new_version }}" \
          --title "Release v${{ steps.increment_version.outputs.new_version }}" \
          --notes "Automated release v${{ steps.increment_version.outputs.new_version }}
        
        Previous version: v${{ steps.increment_version.outputs.current_version }}
        
        Changes:
        - Auto-incremented version from ${{ steps.increment_version.outputs.current_version }} to ${{ steps.increment_version.outputs.new_version }}"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    outputs:
      version: ${{ steps.increment_version.outputs.new_version }}

  # Build and publish Docker images to GitHub Container Registry
  docker-build-publish:
    needs: test-and-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main  # Get the latest code after version bump
    
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: linux/amd64,linux/arm64
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository }}
        tags: |
          type=raw,value=latest
          type=raw,value=${{ needs.test-and-release.outputs.version }}
    
    - name: Build and push standard image (multi-arch)
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
